# CSE233 - Operating Systems - Assignment 2 Answers

## 1. Code Examples and Explanations (Lab 5)

### Exercise 1: Using fork() in C (`process_creation.c`)

**Code Description:**
This program demonstrates the use of the `fork()` system call to create a new process. When `fork()` is called, the operating system creates a near-identical copy of the calling process (the parent).

**Explanation:**
- `pid_t pid = fork();`: This is the core of the program.
    - In the **parent process**, `fork()` returns the Process ID (PID) of the newly created child process (a positive integer).
    - In the **child process**, `fork()` returns 0.
    - If `fork()` fails, it returns -1.
- The `if-else if-else` block is used to differentiate between the parent and child processes based on the return value of `fork()`. Both processes execute the code immediately following the `fork()` call. The output will show two lines, one for the parent and one for the child, each with a unique PID.

### Exercise 5: Role of the Linker (`file1.c` and `file2.c`)

**Code Description:**
These two files are compiled separately and then linked together. `file2.c` contains the `main` function and calls the `hello()` function, which is defined in `file1.c`.

**Explanation:**
The **Linker** is a program that takes one or more object files (generated by the compiler from source code) and combines them into a single executable file.
- **Symbol Resolution:** The compiler for `file2.c` sees the declaration `void hello();` and assumes the function exists. The linker's job is to find the actual definition of `hello()` (which is in the object file for `file1.c`) and connect the call in `file2.c` to the definition in `file1.c`.
- **Relocation:** The linker also assigns final addresses to all code and data sections, resolving any relative addresses into absolute ones, making the program ready to be loaded into memory and executed.

### Exercise 6: Role of the Loader (`simple_program.c`)

**Code Description:**
A simple C program that prints a string. The `ldd` utility is used to inspect its dynamic dependencies.

**Explanation:**
The **Loader** is the part of the operating system that is responsible for loading programs into memory and preparing them for execution.
- **Loading:** It reads the executable file (created by the linker) from disk and copies the program's code and data into the main memory.
- **Dynamic Linking:** For programs that use shared libraries (like `simple_program.c` which uses the standard C library, `libc`), the loader (or a dynamic linker/loader) is responsible for finding these libraries on the system, loading them into memory, and linking them to the running program at runtime. The `ldd` command shows which shared libraries the program depends on *before* it is run.

## 2. Explain what is the job of the Linker.

The **Linker** is a system program that combines various pieces of code and data into a single executable file. Its primary jobs are:
1.  **Symbol Resolution:** It resolves references between different object files. For example, if a function in one file calls a function defined in another file, the linker finds the definition and connects the call site to the correct address.
2.  **Relocation:** It assigns final memory addresses to all code and data sections within the executable. It adjusts all address-dependent code (like jump instructions or data references) to reflect these final addresses.
3.  **Library Inclusion:** It incorporates code from system libraries (like the C standard library) that the program uses. This can be done by including the library code directly (static linking) or by setting up references to shared libraries that will be loaded at runtime (dynamic linking).

## 3. Explain what is the job of the Loader.

The **Loader** is a component of the operating system kernel that prepares a program for execution. Its primary jobs are:
1.  **Allocation:** It determines the size of the program (code and data) and allocates the necessary memory space for it.
2.  **Loading:** It reads the executable file from the secondary storage (disk) and copies the program's instructions and data into the allocated memory.
3.  **Relocation (Runtime):** If the program was compiled to be relocatable (Position-Independent Code - PIC), the loader may perform final address adjustments to ensure the program runs correctly from its actual memory location.
4.  **Linking (Dynamic):** If the program uses shared libraries, the loader (or a dynamic linker) finds the required libraries, loads them into memory, and connects their functions and data to the running program.
5.  **Initialization:** It sets up the program's execution environment, such as the stack and registers, and then transfers control to the program's entry point (e.g., the `main` function) to begin execution.
